<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>EchoScope â€” åå°„æ¸¬å®šï¼ˆå˜ä¸€HTMLç‰ˆ v1.5S / Macå¯¾å¿œå¼·åŒ–ï¼‰</title>
<style>
*{box-sizing:border-box}body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,'Hiragino Kaku Gothic ProN','Noto Sans JP',sans-serif;margin:0;color:#1b1f23;background:#f6f8fa}
header{padding:16px 20px;background:#fff;border-bottom:1px solid #e5e7eb}
h1{margin:.1em 0;font-size:22px}
.panel{background:#fff;border-bottom:1px solid #e5e7eb;padding:12px 16px}
.row{display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin:6px 0}
label{display:flex;flex-direction:column;font-size:12px;color:#555;gap:4px}
label.inline{flex-direction:row;align-items:center;margin-left:6px}
input[type=number], select{padding:6px 8px;border:1px solid #c9d2e0;border-radius:8px;background:#f7faff;min-width:90px}
button{padding:8px 12px;border-radius:10px;border:1px solid #c7d0e0;background:#e9effa;cursor:pointer}
button:disabled{opacity:.5;cursor:not-allowed}
#status{margin-left:8px;color:#555}
.warn{background:#fff3cd;border:1px solid #ffe69c;color:#775f00;padding:8px 12px;border-radius:10px}
.error{background:#fde2e1;border:1px solid #f5b5b0;color:#942a23;padding:8px 12px;border-radius:10px}
.canvas-wrap{padding:12px 16px}
#wave{width:100%;height:300px;border-radius:12px;background:#fff;border:1px solid #e5e7eb;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.results{background:#fff;border-top:1px solid #e5e7eb;padding:12px 16px;display:grid;gap:6px}
.small{font-size:12px;color:#6b7280}
.kv{display:grid;grid-template-columns:140px 1fr;gap:6px 10px}
kbd{padding:2px 6px;border:1px solid #c7d0e0;border-radius:6px;background:#f7faff}
</style>
</head>
<body>
<header>
  <h1>EchoScope â€” åå°„æ¸¬å®šï¼ˆãƒ›ãƒ¯ã‚¤ãƒˆãƒã‚¤ã‚ºçŸ­ãƒ‘ãƒ«ã‚¹ + æ‰‹å‹• tâ‚/tâ‚‚ï¼‰å˜ä¸€HTML v1.5S</h1>
  <div id="originWarn" class="warn" style="display:none">ã“ã®ãƒšãƒ¼ã‚¸ã¯ <b>å®‰å…¨ãªã‚ªãƒªã‚¸ãƒ³(HTTPS)</b> ã§é–‹ã‹ã‚Œã¦ã„ã¾ã›ã‚“ã€‚Chrome/Safariã¨ã‚‚ã« <b>file://</b> ã§ã¯<b>ãƒã‚¤ã‚¯ãŒä½¿ãˆã¾ã›ã‚“</b>ã€‚<br>å¯¾ç­–ï¼š<b>GitHub Pages ç­‰ã®HTTPS</b>ã€ã¾ãŸã¯ <b>http://localhost</b> ã§é–‹ã„ã¦ãã ã•ã„ã€‚</div>
</header>

<section class="panel">
  <div class="row">
    <label>éŒ²éŸ³æ™‚é–“ (ms)
      <input id="recMs" type="number" min="200" step="50" value="1200">
    </label>
    <label>ãƒ—ãƒ¬ãƒ­ãƒ¼ãƒ« (ms)
      <input id="preMs" type="number" min="50" step="10" value="150">
    </label>
    <label>ãƒ‘ãƒ«ã‚¹ç¨®åˆ¥
      <select id="pulseType">
        <option value="noise">ãƒã‚¤ã‚º</option>
        <option value="sine" selected>ã‚µã‚¤ãƒ³(1.5kHz)</option>
      </select>
    </label>
    <label>ãƒ‘ãƒ«ã‚¹é•· (ms)
      <input id="pulseMs" type="number" min="2" step="1" value="80">
    </label>
    <label>ãƒ‘ãƒ«ã‚¹éŸ³é‡ (0ã€œ1)
      <input id="pulseVol" type="number" min="0" max="1" step="0.05" value="1.0">
    </label>
  </div>

  <div class="row">
    <label>åŒ…çµ¡çª“ (ms)
      <input id="envMs" type="number" min="0.3" step="0.1" value="1.2">
    </label>
    <label>ç›¸å¯¾é–¾å€¤ (0ã€œ1)
      <input id="thresh" type="number" min="0.02" max="1" step="0.01" value="0.06">
    </label>
    <label>æœ€å°ãƒ”ãƒ¼ã‚¯é–“éš” (ms)
      <input id="minSep" type="number" min="0.5" step="0.1" value="2.5">
    </label>
    <label class="inline"><input id="showCands" type="checkbox" checked> å€™è£œè¡¨ç¤º</label>
    <button id="applyTop2">å€™è£œâ†’tâ‚/tâ‚‚</button>
  </div>

  <div class="row">
    <label style="min-width:220px">ãƒã‚¤ã‚¯ï¼ˆå…¥åŠ›ãƒ‡ãƒã‚¤ã‚¹ï¼‰
      <select id="micSelect"><option value="default">ï¼ˆæ—¢å®šï¼‰</option></select>
    </label>
    <button id="refreshMics">â†» ãƒ‡ãƒã‚¤ã‚¹æ›´æ–°</button>
    <button id="diagBtn">è¨ºæ–­</button>
    <span id="status">æº–å‚™OK</span>
  </div>

  <div class="row">
    <button id="measureBtn">ç™ºéŸ³ã—ã¦æ¸¬å®š</button>
    <button id="startBtn">éŒ²éŸ³ã®ã¿</button>
    <button id="stopBtn" disabled>åœæ­¢</button>
    <button id="pulseTest">ãƒ‘ãƒ«ã‚¹å†ç”Ÿãƒ†ã‚¹ãƒˆ</button>
    <button id="demoSignal">ãƒ‡ãƒ¢ä¿¡å·ç”Ÿæˆ</button>
    <button id="exportBtn" disabled>CSVæ›¸ãå‡ºã—</button>
  </div>
</section>

<section class="canvas-wrap">
  <canvas id="wave" title="tâ‚/tâ‚‚ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ã‹ã‚‰ã€æ³¢å½¢ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãƒ”ãƒ¼ã‚¯ä½ç½®ã‚’æ±ºã‚ã¾ã™"></canvas>
</section>

<section class="row" style="padding:0 16px 12px">
  <button id="setT1">tâ‚æ‰‹å‹•</button>
  <button id="setT2">tâ‚‚æ‰‹å‹•</button>
  <button id="clearMarks">ãƒãƒ¼ã‚¯æ¶ˆå»</button>
</section>

<section class="results">
  <div>ã‚µãƒ³ãƒ—ãƒ«ãƒ¬ãƒ¼ãƒˆ: <span id="sr">â€”</span> Hz</div>
  <div>tâ‚: <span id="t1">â€”</span> s ï¼ Aâ‚: <span id="a1">â€”</span></div>
  <div>tâ‚‚: <span id="t2">â€”</span> s ï¼ Aâ‚‚: <span id="a2">â€”</span></div>
  <div>Î”t = <span id="dt">â€”</span> s</div>
</section>

<section class="panel" id="diagPanel" style="display:none">
  <h3>è¨ºæ–­æƒ…å ±</h3>
  <div class="kv small" id="diagKV"></div>
</section>

<footer style="padding:12px 16px">
  <div class="small">macOS ã§ãƒã‚¤ã‚¯ãŒå‡ºãªã„æ™‚ã¯ï¼š<br>
  1) <b>ã‚·ã‚¹ãƒ†ãƒ è¨­å®š â†’ ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ã¨ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ â†’ ãƒã‚¤ã‚¯</b>ã§ãƒ–ãƒ©ã‚¦ã‚¶ï¼ˆChrome/Safariï¼‰ã‚’<b>ã‚ªãƒ³</b><br>
  2) Chrome: ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒãƒ¼å·¦ã® <kbd>ğŸ”’</kbd> â†’ ãƒã‚¤ã‚¯ã‚’<b>è¨±å¯</b> ï¼ Safari: <b>è¨­å®š â†’ Webã‚µã‚¤ãƒˆ â†’ ãƒã‚¤ã‚¯</b> ã§è©²å½“ã‚µã‚¤ãƒˆã‚’<b>è¨±å¯</b><br>
  3) æ—¢ã«ãƒã‚¤ã‚¯ã‚’ä½¿ã£ã¦ã„ã‚‹ã‚¢ãƒ—ãƒªï¼ˆZoom/Meetç­‰ï¼‰ã‚’çµ‚äº†<br>
  4) ãã‚Œã§ã‚‚ä¸å¯ãªã‚‰ã€ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£ãƒ¢ãƒ‹ã‚¿ã§ <b>coreaudiod</b> ã‚’çµ‚äº†ï¼ˆè‡ªå‹•å†èµ·å‹•ï¼‰</div>
</footer>

<script>
// ---- Inline worklet as Blob (optional) ----
const RECORDER_WORKLET_CODE = `
class RecorderProcessor extends AudioWorkletProcessor {
  process(inputs, outputs){
    const input = inputs[0];
    const out = outputs[0];
    if(input && input[0]){
      const ch0 = input[0];
      const copy = new Float32Array(ch0.length);
      copy.set(ch0);
      this.port.postMessage({type:'samples', payload: copy}, [copy.buffer]);
    }
    if(out && out[0]){ out[0].fill(0); }
    return true;
  }
}
registerProcessor('recorder', RecorderProcessor);
`;
// -------------------------------------------

let audioCtx;
let recNode;        // AudioWorkletNode or ScriptProcessorNode
let stream;
let buffer = [];
let sampleRate = 48000;

const isSecure = location.protocol === 'https:' || location.hostname === 'localhost';
const $ = (s)=>document.querySelector(s);
const wave = $("#wave");
const g = wave.getContext("2d");

const recMsEl = $("#recMs");
const preMsEl = $("#preMs");
const pulseTypeEl = $("#pulseType");
const pulseMsEl = $("#pulseMs");
const pulseVolEl = $("#pulseVol");

const envMsEl = $("#envMs");
const threshEl = $("#thresh");
const minSepEl = $("#minSep");
const showCandsEl = $("#showCands");
const applyTop2Btn = $("#applyTop2");

const micSelect = $("#micSelect");
const refreshMicsBtn = $("#refreshMics");
const diagBtn = $("#diagBtn");

const measureBtn = $("#measureBtn");
const startBtn = $("#startBtn");
const stopBtn = $("#stopBtn");
const pulseTestBtn = $("#pulseTest");
const demoSignalBtn = $("#demoSignal");
const exportBtn = $("#exportBtn");
const setT1Btn = $("#setT1");
const setT2Btn = $("#setT2");
const clearMarksBtn = $("#clearMarks");
const statusEl = $("#status");
const originWarn = $("#originWarn");

const srEl = $("#sr");
const t1El = $("#t1");
const a1El = $("#a1");
const t2El = $("#t2");
const a2El = $("#a2");
const dtEl = $("#dt");

const diagPanel = $("#diagPanel");
const diagKV = $("#diagKV");

let lastData = null;
let marks = {t1:null, t2:null};
let candidates = [];
let pickMode = null;

if(!isSecure){
  originWarn.style.display = 'block';
}

function setStatus(s){ statusEl.textContent = s; }

// --- Canvas responsive ---
function syncCanvasSize(){
  const rect = wave.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  wave.width = Math.max(1, Math.round(rect.width * dpr));
  wave.height = Math.max(1, Math.round(300 * dpr));
  g.setTransform(dpr, 0, 0, dpr, 0, 0);
}
new ResizeObserver(syncCanvasSize).observe(wave);
syncCanvasSize();

function resetUI(){
  [t1El,a1El,t2El,a2El,dtEl].forEach(el=>el.textContent="â€”");
  exportBtn.disabled = true;
  draw([], []);
  lastData = null; marks = {t1:null, t2:null}; candidates = [];
}
resetUI();

async function loadWorkletFromBlob(ctx){
  const blob = new Blob([RECORDER_WORKLET_CODE], {type:'application/javascript'});
  const url = URL.createObjectURL(blob);
  try{
    await ctx.audioWorklet.addModule(url);
    return true;
  }catch(e){
    console.warn("Worklet load failed, fallback:", e);
    return false;
  }finally{
    URL.revokeObjectURL(url);
  }
}

async function initAudio(){
  if(audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  sampleRate = audioCtx.sampleRate;
  srEl.textContent = sampleRate.toFixed(0);
}

async function listMics(){
  try{
    const devices = await navigator.mediaDevices.enumerateDevices();
    const inputs = devices.filter(d=>d.kind === 'audioinput');
    micSelect.innerHTML = '<option value="default">ï¼ˆæ—¢å®šï¼‰</option>';
    inputs.forEach(d=>{
      const opt = document.createElement('option');
      opt.value = d.deviceId;
      opt.textContent = d.label || `ãƒã‚¤ã‚¯ (${d.deviceId.slice(0,6)}â€¦)`;
      micSelect.appendChild(opt);
    });
    if(inputs.length===0){
      setStatus("ãƒã‚¤ã‚¯ãŒåˆ—æŒ™ã§ãã¾ã›ã‚“ï¼ˆè¨±å¯å¾…ã¡/ãƒ‡ãƒã‚¤ã‚¹ãªã—ï¼‰ã€‚éŒ²éŸ³ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦è¨±å¯ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’å‡ºã—ã¦ãã ã•ã„ã€‚");
    }
  }catch(e){
    setStatus("ãƒ‡ãƒã‚¤ã‚¹åˆ—æŒ™ã«å¤±æ•—: " + e.message);
  }
}
refreshMicsBtn.addEventListener('click', listMics);
listMics();

async function attachMic(){
  if(!isSecure){
    throw new Error("ä¸æ­£ãªã‚ªãƒªã‚¸ãƒ³ï¼ˆHTTPSã¾ãŸã¯localhostã®ã¿ã§ãƒã‚¤ã‚¯å¯ï¼‰");
  }
  const selected = micSelect.value;
  const base = { echoCancellation:false, noiseSuppression:false, autoGainControl:false };
  const c1 = { audio: { ...base, deviceId: selected==='default'? undefined : { exact: selected } } };
  const c2 = { audio: { deviceId: selected==='default'? undefined : { exact: selected } } };
  const c3 = { audio: true };
  let lastErr;
  for(const c of [c1, c2, c3]){
    try{
      stream = await navigator.mediaDevices.getUserMedia(c);
      break;
    }catch(e){
      lastErr = e;
      stream = null;
    }
  }
  if(!stream) throw new Error("getUserMedia å–å¾—å¤±æ•—: " + (lastErr && (lastErr.name + " " + lastErr.message)));
  const src = audioCtx.createMediaStreamSource(stream);

  // Try worklet first, then fallback to ScriptProcessor
  let workletOK = false;
  try{ workletOK = await loadWorkletFromBlob(audioCtx); }catch{}
  if(workletOK){
    recNode = new AudioWorkletNode(audioCtx, 'recorder');
    src.connect(recNode);
    recNode.connect(audioCtx.destination);
    recNode.port.onmessage = (e)=>{
      if(e.data.type === 'samples'){
        const arr = new Float32Array(e.data.payload);
        buffer.push(arr);
      }
    };
  }else{
    const proc = audioCtx.createScriptProcessor(2048, 1, 1);
    proc.onaudioprocess = (ev)=>{
      const ch = ev.inputBuffer.getChannelData(0);
      const copy = new Float32Array(ch.length);
      copy.set(ch);
      buffer.push(copy);
      ev.outputBuffer.getChannelData(0).fill(0);
    };
    src.connect(proc); proc.connect(audioCtx.destination);
    recNode = proc;
  }
  buffer = [];
}

function teardown(){
  try{ recNode && recNode.disconnect && recNode.disconnect(); }catch{}
  try{ audioCtx && audioCtx.close && audioCtx.close(); }catch{}
  try{ stream && stream.getTracks && stream.getTracks().forEach(t=>t.stop()); }catch{}
  recNode = null; audioCtx = null; stream = null;
}

function stopRec(){
  stopBtn.disabled = true;
  setStatus("åœæ­¢å‡¦ç†...");
  teardown();

  const totalLen = buffer.reduce((acc,a)=>acc + a.length, 0);
  const data = new Float32Array(totalLen);
  let o=0; for(const a of buffer){ data.set(a, o); o+=a.length; }

  lastData = data;
  updateCandidates();
  redrawAll();
  exportBtn.disabled = false;
  exportBtn.onclick = () => exportCSV();
  setStatus("å®Œäº†ï¼šæ³¢å½¢ã‹ã‚‰ tâ‚/tâ‚‚ ã‚’ã‚¯ãƒªãƒƒã‚¯ã§æŒ‡å®šã—ã¦ãã ã•ã„ï¼ˆå€™è£œã¯å‚è€ƒè¡¨ç¤ºï¼‰");
  startBtn.disabled = false;
  measureBtn.disabled = false;
}

async function startRecOnly(){
  try{
    startBtn.disabled = true; stopBtn.disabled = false;
    setStatus("åˆæœŸåŒ–...");
    await initAudio();
    await audioCtx.resume();
    await attachMic();
    setStatus("éŒ²éŸ³ä¸­...");
    const ms = Math.max(200, parseInt(recMsEl.value||"1200",10));
    setTimeout(stopRec, ms);
  }catch(err){
    console.error(err);
    setStatus("éŒ²éŸ³ã‚¨ãƒ©ãƒ¼: " + err.message);
    startBtn.disabled = false;
    stopBtn.disabled = true;
  }
}

async function measureWithPulse(){
  try{
    measureBtn.disabled = true; stopBtn.disabled = false;
    setStatus("åˆæœŸåŒ–...");
    await initAudio();
    await audioCtx.resume();
    await attachMic();
    const recMs = Math.max(200, parseInt(recMsEl.value||"1200",10));
    const preMs = Math.max(50, parseInt(preMsEl.value||"150",10));
    const pulseMs = Math.max(2, parseInt(pulseMsEl.value||"80",10));
    const vol = Math.max(0, Math.min(1, parseFloat(pulseVolEl.value||"1.0")));
    const type = pulseTypeEl.value;

    const startTime = audioCtx.currentTime + Math.max(0.05, preMs/1000);
    playPulseAt(startTime, pulseMs/1000, vol, type);

    setStatus("éŒ²éŸ³ä¸­...ï¼ˆãƒ‘ãƒ«ã‚¹â†’æ‰‹å‹•ãƒ”ãƒ¼ã‚¯ï¼‰");
    setTimeout(stopRec, recMs);
  }catch(err){
    console.error(err);
    setStatus("ã‚¨ãƒ©ãƒ¼: " + err.message);
    measureBtn.disabled = false;
  }
}

function playPulseAt(startTime, durSec, vol, type){
  const g = audioCtx.createGain();
  g.gain.value = 0;
  let src;
  if(type === "sine"){
    src = audioCtx.createOscillator();
    src.type = "sine";
    src.frequency.value = 1500;
  }else{
    const len = Math.max(1, Math.floor(sampleRate * durSec));
    const noise = audioCtx.createBuffer(1, len, sampleRate);
    const ch = noise.getChannelData(0);
    for(let i=0;i<ch.length;i++) ch[i] = (Math.random()*2-1);
    const bs = audioCtx.createBufferSource();
    bs.buffer = noise;
    src = bs;
  }

  const hp = audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value = 600;
  const lp = audioCtx.createBiquadFilter(); lp.type='lowpass';  lp.frequency.value = 7000;

  src.connect(hp).connect(lp).connect(g).connect(audioCtx.destination);

  const a = g.gain;
  a.setValueAtTime(0, startTime);
  a.linearRampToValueAtTime(vol, startTime + 0.003);
  a.exponentialRampToValueAtTime(0.001, startTime + durSec);
  a.setValueAtTime(0, startTime + durSec + 0.02);

  if(src.start) src.start(startTime);
  if(src.stop)  src.stop(startTime + durSec + 0.03);
}

function movingAverageAbs(data, win){
  const out = new Float32Array(data.length);
  let sum = 0;
  for(let i=0;i<data.length;i++){
    const v = Math.abs(data[i]);
    sum += v;
    if(i>=win) sum -= Math.abs(data[i-win]);
    out[i] = sum / Math.min(i+1, win);
  }
  return out;
}

function findCandidates(data){
  if(!data || data.length===0) return [];
  const sr = sampleRate;
  const envWin = Math.max(1, Math.floor(sr * (parseFloat(envMsEl.value||"1.2")/1000)));
  const env = movingAverageAbs(data, envWin);
  let maxv = 0; for(let i=0;i<env.length;i++) if(env[i]>maxv) maxv=env[i];
  const Trel = Math.max(0.0, Math.min(1.0, parseFloat(threshEl.value||"0.06")));
  const T = (maxv>0) ? (Trel * maxv) : Trel;

  const minSep = Math.max(1, Math.floor(sr * (parseFloat(minSepEl.value||"2.5")/1000)));
  const cands = [];
  let i = 1;
  while(i < env.length-1){
    if(env[i] >= T && env[i] >= env[i-1] && env[i] >= env[i+1]){
      cands.push(i);
      i += minSep;
    }else{
      i++;
    }
  }

  const ref = [];
  const refineWin = Math.max(1, Math.floor(sr * 0.001));
  for(const p of cands){
    let bestIdx = p, bestVal = 0;
    const s = Math.max(0, p - refineWin), e = Math.min(data.length, p + refineWin + 1);
    for(let k=s;k<e;k++){
      const v = Math.abs(data[k]);
      if(v > bestVal){ bestVal = v; bestIdx = k; }
    }
    ref.push(bestIdx);
  }
  return ref.slice(0, 8);
}

function updateCandidates(){ candidates = findCandidates(lastData); }
function redrawAll(){
  const rect = wave.getBoundingClientRect();
  const Wcss = rect.width, Hcss = rect.height;
  const ctx = g;
  ctx.clearRect(0,0,Wcss,Hcss);
  ctx.fillStyle = "#fff"; ctx.fillRect(0,0,Wcss,Hcss);
  ctx.strokeStyle = "#e5e7eb"; ctx.beginPath(); ctx.moveTo(0,Hcss/2); ctx.lineTo(Wcss,Hcss/2); ctx.stroke();

  if(!data || data.length===0) { var data = lastData; } // ensure 'data' var
  if(!data || data.length===0) return;

  const step = Math.ceil(data.length / Math.max(1, Math.floor(Wcss)));
  ctx.strokeStyle = "#4f6aa0"; ctx.beginPath();
  for(let x=0; x<Math.floor(Wcss); x++){
    const start = x*step;
    const end = Math.min((x+1)*step, data.length);
    let min = 1, max = -1;
    for(let i=start;i<end;i++){
      const v = data[i];
      if(v<min) min=v; if(v>max) max=v;
    }
    const y1 = Hcss/2 - min * (Hcss*0.45);
    const y2 = Hcss/2 - max * (Hcss*0.45);
    ctx.moveTo(x, y1);
    ctx.lineTo(x, y2);
  }
  ctx.stroke();

  const marksList = [
    ...(marks.t1!=null?[{index:marks.t1,color:"#1f77b4"}]:[]),
    ...(marks.t2!=null?[{index:marks.t2,color:"#d62728"}]:[]),
    ...(showCandsEl.checked ? candidates.map(i=>({index:i,color:"#888"})) : [])
  ];
  marksList.forEach(m => {
    if(!lastData) return;
    const x = Math.floor((m.index / lastData.length) * Wcss);
    ctx.fillStyle = m.color || "#d24";
    ctx.fillRect(x, 0, 2, Hcss);
  });
}

function updateReadoutNumbers(){
  const sr = sampleRate;
  let t1=NaN,a1=NaN,t2=NaN,a2=NaN,dt=NaN;
  if(lastData && marks.t1!=null){ t1 = marks.t1/sr; a1 = Math.abs(lastData[marks.t1]); }
  if(lastData && marks.t2!=null){ t2 = marks.t2/sr; a2 = Math.abs(lastData[marks.t2]); }
  if(isFinite(t1) && isFinite(t2)) dt = t2 - t1;

  t1El.textContent = isFinite(t1)?t1.toFixed(6):"â€”";
  a1El.textContent = isFinite(a1)?a1.toFixed(4):"â€”";
  t2El.textContent = isFinite(t2)?t2.toFixed(6):"â€”";
  a2El.textContent = isFinite(a2)?a2.toFixed(4):"â€”";
  dtEl.textContent = isFinite(dt)?dt.toFixed(6):"â€”";
}

function exportCSV(){
  const sr = sampleRate;
  let t1="",a1="",t2="",a2="",dt="";
  if(marks.t1!=null){ t1 = (marks.t1/sr).toFixed(6); a1 = Math.abs(lastData[marks.t1]).toFixed(6); }
  if(marks.t2!=null){ t2 = (marks.t2/sr).toFixed(6); a2 = Math.abs(lastData[marks.t2]).toFixed(6); }
  if(marks.t1!=null && marks.t2!=null){ dt = ((marks.t2-marks.t1)/sr).toFixed(6); }
  const header = ["sample_rate_Hz","t1_s","A1","t2_s","A2","delta_t_s"];
  let csv = header.join(",") + "Â¥n";
  csv += [sr, t1, a1, t2, a2, dt].join(",") + "Â¥n";
  const blob = new Blob([csv], {type:"text/csv"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "reflection_result_v15S.csv";
  a.click();
  URL.revokeObjectURL(a.href);
}

// Demo signal so you can click even without mic
function makeDemoSignal(){
  const sr = 48000;
  const dur = Math.max(0.5, parseInt(recMsEl.value||"1200",10)/1000);
  const N = Math.floor(sr*dur);
  const arr = new Float32Array(N);
  const t1s = Math.min(0.08, dur*0.2); // 80ms
  const dt = 0.0025; // 2.5ms echo
  const t2s = t1s + dt;
  const i1 = Math.floor(t1s*sr);
  const i2 = Math.floor(t2s*sr);
  // short pulses
  for(let k=-30; k<=30; k++){
    if(i1+k>=0 && i1+k<N) arr[i1+k] += Math.exp(-0.5*(k/10)**2);
    if(i2+k>=0 && i2+k<N) arr[i2+k] += 0.7*Math.exp(-0.5*(k/10)**2);
  }
  // noise
  for(let i=0;i<N;i++){ arr[i] += (Math.random()-0.5)*0.02; }
  return arr;
}

function useDemo(){
  lastData = makeDemoSignal();
  candidates = findCandidates(lastData);
  marks = {t1:candidates[0]??null, t2:candidates[1]??null};
  redrawAll();
  updateReadoutNumbers();
  setStatus("ãƒ‡ãƒ¢ä¿¡å·ã‚’è¡¨ç¤ºã—ã¾ã—ãŸã€‚tâ‚/tâ‚‚ã‚’ã‚¯ãƒªãƒƒã‚¯ã§èª¿æ•´ã§ãã¾ã™ã€‚");
  exportBtn.disabled = false;
  exportBtn.onclick = () => exportCSV();
}

// Diagnostics
function addKV(k,v){
  const kdiv=document.createElement('div'); kdiv.textContent=k;
  const vdiv=document.createElement('div'); vdiv.textContent=String(v);
  diagKV.appendChild(kdiv); diagKV.appendChild(vdiv);
}

async function showDiag(){
  diagKV.innerHTML = "";
  addKV("Secure origin?", (location.protocol==='https:' || location.hostname==='localhost'));
  addKV("UserAgent", navigator.userAgent);
  try{
    const devices = await navigator.mediaDevices.enumerateDevices();
    const nIn = devices.filter(d=>d.kind==='audioinput').length;
    const nOut = devices.filter(d=>d.kind==='audiooutput').length;
    addKV("audioinput devices", nIn);
    addKV("audiooutput devices", nOut);
    const labels = devices.filter(d=>d.kind==='audioinput').map(d=>d.label||"(labelãªã—)");
    addKV("input labels", labels.join(" | "));
  }catch(e){
    addKV("enumerateDevices error", e.message);
  }
  if(navigator.permissions && navigator.permissions.query){
    try{
      const st = await navigator.permissions.query({name:'microphone'});
      addKV("permissions(microphone)", st.state);
    }catch(e){
      addKV("permissions API", "æœªå¯¾å¿œ/å¤±æ•—");
    }
  }else{
    addKV("permissions API", "æœªå¯¾å¿œ");
  }
  diagPanel.style.display = "block";
}

diagBtn.addEventListener('click', showDiag);

// UI events
setT1Btn.addEventListener("click", ()=>{ pickMode = (pickMode==='t1'?null:'t1'); setStatus(pickMode==='t1'?'tâ‚ã‚’ã‚¯ãƒªãƒƒã‚¯ã§æŒ‡å®š':''); });
setT2Btn.addEventListener("click", ()=>{ pickMode = (pickMode==='t2'?null:'t2'); setStatus(pickMode==='t2'?'tâ‚‚ã‚’ã‚¯ãƒªãƒƒã‚¯ã§æŒ‡å®š':''); });
clearMarksBtn.addEventListener("click", ()=>{ marks = {t1:null, t2:null}; redrawAll(); updateReadoutNumbers(); });
[envMsEl, threshEl, minSepEl, showCandsEl].forEach(el=>{
  el.addEventListener("input", ()=>{ updateCandidates(); redrawAll(); updateReadoutNumbers(); });
});
applyTop2Btn.addEventListener("click", ()=>{
  if(candidates.length >= 2){ marks.t1 = candidates[0]; marks.t2 = candidates[1]; redrawAll(); updateReadoutNumbers(); }
});

wave.addEventListener("click", (ev)=>{
  if(!pickMode || !lastData) return;
  const rect = wave.getBoundingClientRect();
  const x = ev.clientX - rect.left;
  const Wcss = rect.width; // è¡¨ç¤ºå¹…ã§æ­£è¦åŒ–ï¼ˆã‚ºãƒ¬å¯¾ç­–ï¼‰
  const idx = Math.round((x / Wcss) * lastData.length);
  // refine to local |.| max Â±1ms
  const sr = sampleRate;
  const win = Math.max(1, Math.floor(sr*0.001));
  let best = idx, bestVal = 0;
  for(let k=Math.max(0, idx-win); k<Math.min(lastData.length, idx+win+1); k++){
    const v = Math.abs(lastData[k]);
    if(v > bestVal){ bestVal = v; best = k; }
  }
  if(pickMode==='t1') marks.t1 = best;
  if(pickMode==='t2') marks.t2 = best;
  pickMode = null;
  redrawAll();
  updateReadoutNumbers();
  setStatus("æ‰‹å‹•æŒ‡å®šã‚’é©ç”¨ã—ã¾ã—ãŸ");
});

async function pulseTest(){
  try{
    await initAudio(); await audioCtx.resume();
    const type = pulseTypeEl.value;
    const dur = Math.max(2, parseInt(pulseMsEl.value||"80",10))/1000;
    const vol = Math.max(0, Math.min(1, parseFloat(pulseVolEl.value||"1.0")));
    const t = audioCtx.currentTime + 0.10;
    playPulseAt(t, dur, vol, type);
    setStatus("ãƒ‘ãƒ«ã‚¹ã‚’å†ç”Ÿã—ã¾ã—ãŸï¼ˆéŒ²éŸ³ãªã—ï¼‰");
  }catch(err){
    console.error(err);
    setStatus("ãƒ‘ãƒ«ã‚¹ãƒ†ã‚¹ãƒˆå¤±æ•—: " + err.message);
  }
}

measureBtn.addEventListener("click", measureWithPulse);
startBtn.addEventListener("click", startRecOnly);
stopBtn.addEventListener("click", stopRec);
pulseTestBtn.addEventListener("click", ()=>{ pulseTest(); });
demoSignalBtn.addEventListener("click", ()=>{ useDemo(); });

// Try to prompt permission early to get device labels
(async ()=>{
  try{
    if(isSecure){
      await navigator.mediaDevices.getUserMedia({audio:true});
    }
  }catch(e){ /* ignore â€” user may allow later */ }
  listMics();
})();
</script>
</body>
</html>
